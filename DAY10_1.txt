Practice 1

•	Create a procedure called USER_QUERY_EMP that accepts three parameters. Parameter p_myeno is of IN parameter mode which provides the empno value. The other two parameters 
	p_myjob and p_mysal are of OUT mode. The procedure retrieves the salary and job of an employee with the provided employee number and assigns those to the two OUT parameters 
	respectively. The procedure should handle the error if the empno does not exist in the EMP table by displaying an appropriate message. Use bind variables for the two OUT 
	Parameters.
•	Compile the code, invoke the procedure, and display the salary and job title for employee number 7839. Do the same for employee number 7123.

SOLUTION:-

	mysql> DELIMITER //
	mysql> DROP PROCEDURE IF EXISTS p20//
	Query OK, 0 rows affected (0.25 sec)

	mysql> CREATE PROCEDURE USER_QUERY_EMP(IN EMP_ID INT, OUT EMP_SAL INT, OUT EMP_JOB VARCHAR(20))
        -> BEGIN
    	-> SELECT JOB,SAL INTO EMP_JOB,EMP_SAL FROM emp WHERE EMPNO=EMP_ID;
    	-> END//
	Query OK, 0 rows affected (0.15 sec)

	mysql> DELIMITER ;
	mysql> CALL USER_QUERY_EMP(7839,@Y,@Z);
	Query OK, 1 row affected (0.00 sec)

	mysql> SELECT @Y,@Z;
	+------+-----------+
	| @Y   | @Z        |
	+------+-----------+
	| 5000 | PRESIDENT |
	+------+-----------+
	1 row in set (0.00 sec)

Practice 2

•	Create a function named USER_ANNUAL_COMP that has three parameters p_eno, p_sal and p_comm for passing on the values of an employee number, the current salary and commission of 
	the employee respectively. The function calculates and returns the annual compensation of the employee by using the following formula. annual_compensation =  (p_sal+p_comm)*12
     	 If the salary or commission value is NULL then zero should be substituted for it. 
•	Give a call to USER_ANNUAL_COMP from a SELECT statement, against the EMP table.

SOLUTION:-
	DELIMITER //
	DROP FUNCTION IF EXISTS USER_ANNUAL_COMP //
	CREATE FUNCTION USER_ANNUAL_COMP(p_eno INT, p_sal INT, p_comm INT)
	RETURNS INT
	DETERMINISTIC
	BEGIN
	DECLARE ANN_COMP INT;
	IF p_sal IS NULL THEN
		SET p_sal = 0;
	END IF;
	IF p_comm IS NULL THEN
		SET p_comm = 0;
	END IF;
	SET ANN_COMP = (p_sal + p_comm) * 12;
	RETURN ANN_COMP;
	END //
	DELIMITER ;	

Practice 3

•	Create a function named USER_VALID_DEPTNO that has a single parameter p_dno to accept a department number and returns a BOOLEAN value. The function returns TRUE if the department 
	number exists in the DEPT table else it returns FALSE.
•	Create a procedure named SHOW_STRENGTH that accepts department number in a single parameter p_deptno from user. The procedure gives a call to USER_VALID_DEPTNO. If the function 
	returns TRUE then the procedure finds out how many employees are there in the department from the EMP table and displays the same on the screen. If the function returns FALSE 
	then the procedure displays an appropriate error message.
•	Give call to SHOW_STRENGTH by passing on department number 10. Do the same for department number 76

SOLUTION:-
	DELIMITER //
	DROP FUNCTION IF EXISTS USER_VALID_DEPTNO //
	CREATE FUNCTION USER_VALID_DEPTNO(DEPT_NO INT)
	RETURNS VARCHAR(10)
	READS SQL DATA
	DETERMINISTIC
	BEGIN
	DECLARE TABLE_EXISTS VARCHAR(10) DEFAULT "FALSE";
	DECLARE DEPT_COUNT INT DEFAULT 0;
	SELECT COUNT(*) INTO DEPT_COUNT FROM dept WHERE DEPTNO=DEPT_NO;
	IF DEPT_COUNT = 1 THEN
		SET TABLE_EXISTS = "TRUE";
	END IF;
	RETURN TABLE_EXISTS;
	END //
	

	DROP PROCEDURE IF EXISTS SHOW_STRENGTH //
	CREATE PROCEDURE SHOW_STRENGTH(DEPT_NO INT)
	BEGIN
	DECLARE TABLE_EXISTS VARCHAR(10);
	DECLARE EMP_COUNT INT;
	SELECT USER_VALID_DEPTNO(DEPT_NO) INTO TABLE_EXISTS;
	IF TABLE_EXISTS = "FALSE" THEN
		SELECT "INVALID DEPARTMENT NUMBER" AS "MESSAGE";
	ELSE
		SELECT COUNT(*) INTO EMP_COUNT FROM emp WHERE DEPTNO=DEPT_NO;
		SELECT EMP_COUNT AS "COUNT OF EMPLOYEES";
	END IF;
	END //
	DELIMITER ;

	mysql> CALL SHOW_STRENGTH(10);
	+--------------------+
	| COUNT OF EMPLOYEES |
	+--------------------+
	|                  3 |
	+--------------------+
	1 row in set (0.00 sec)

	Query OK, 0 rows affected (0.01 sec)

	mysql> CALL SHOW_STRENGTH(76);
	+---------------------------+
	| MESSAGE                   |
	+---------------------------+
	| INVALID DEPARTMENT NUMBER |
	+---------------------------+
	1 row in set (0.00 sec)

	Query OK, 0 rows affected (0.01 sec)

Practice 4

•	Create a procedure named ADD_EMPLOYEE to hire an employee. Parameters to the procedure are job, mgr, hiredate, salary, commission and deptno. Validate the following:

a. Employee number is not taken as a parameter but is auto generated by using a SEQUENCE. 
b. Job is either ‘CLERK’ or ‘ANALYST’ or ‘SALESMAN’. The input value can be entered in any case (upper or lower or initcap).
c. Mgr is an existing employee.
d. Hiredate is less than system date.
e. Salary must be greater than 800
f. Commission is not null if the job is SALESMAN. For any other job, commission is null.
g. Deptno must exist in the DEPT table.
Insert the record if the above validations are met and display a message ‘1 row inserted’. If the row is not inserted generate an exception and handle it by displaying an appropriate message. 
•	Give a call to ADD_EMPLOYEE through an anonymous PL/SQL block

SOLUTION :-
	DELIMITER //
	DROP PROCEDURE IF EXISTS ADD_EMPLOYEE //
	CREATE PROCEDURE ADD_EMPLOYEE(NAME VARCHAR(20), JOB VARCHAR(20), MGR_ID INT, HIREDATE DATE, SALARY INT, COMMISSION INT, DEPT_NUM INT)
	BEGIN
	DECLARE LAST_EMP_NO INT;
	DECLARE MESSAGE VARCHAR(300);
	DECLARE IF_MGR_EXISTS,IF_DEPARTMENT_EXISTS INT DEFAULT 0;
	DECLARE RECORDS_COUNT INT;
	DECLARE EMP_CUR CURSOR FOR SELECT EMPNO FROM emp;
	SELECT COUNT(*) INTO RECORDS_COUNT FROM emp;
	OPEN EMP_CUR;
	MY_LOOP : LOOP
		IF RECORDS_COUNT = 0 THEN
			LEAVE MY_LOOP;
		END IF;
		FETCH EMP_CUR INTO LAST_EMP_NO;
		SET RECORDS_COUNT = RECORDS_COUNT - 1;
	END LOOP MY_LOOP;
	CLOSE EMP_CUR;
	SELECT COUNT(*) INTO IF_MGR_EXISTS FROM emp WHERE EMPNO=MGR_ID;

	IF JOB IN ("CLERK","ANALYST","SALESMAN") THEN
		IF IF_MGR_EXISTS = 1 THEN
			IF HIREDATE < CURDATE() THEN
				IF SALARY > 800 THEN
					SELECT COUNT(*) INTO IF_DEPARTMENT_EXISTS FROM dept WHERE DEPTNO=DEPT_NUM;
					SET JOB = UPPER(JOB);
					SET LAST_EMP_NO = LAST_EMP_NO + 1;
					IF JOB <> "SALESMAN" AND IF_DEPARTMENT_EXISTS = 1 THEN
						SET COMMISSION = NULL;
						INSERT INTO emp VALUES (LAST_EMP_NO, NAME, JOB, MGR, HIREDATE, SALARY, COMMISSION, DEPT_NUM);
						SET MESSAGE = "1 ROW INSERTED";
					ELSEIF JOB = "SALESMAN" AND COMMISSION IS NOT NULL AND IF_DEPARTMENT_EXISTS = 1 THEN
						INSERT INTO emp VALUES (LAST_EMP_NO, NAME, JOB, MGR, HIREDATE, SALARY, COMMISSION, DEPT_NUM);
						SET MESSAGE = "1 ROW INSERTED";
					ELSEIF IF_DEPARTMENT_EXISTS = 0 THEN
						SET MESSAGE = "DEPARTMENT DOESTN'T EXIST";
					ELSE 
						SET MESSAGE = "SALESMAN CANNOT HAVE COMMISSION AS NULL";
					END IF;
				ELSE
					SET MESSAGE = "SALARY LESS THAN 800";
				END IF; 
			ELSE
				SET MESSAGE = "INVALID HIREDATE. MUST BE LESS THAN SYSTEM DATE";
			END IF;
		ELSE	
			SET MESSAGE =  "INVALID MANAGER ID";
		END IF;
	ELSE 
		SET MESSAGE = "INVALID JOB";
	END IF;
	SELECT MESSAGE;
	END //
	DELIMITER ;

	CALL ADD_EMPLOYEE("A","SALESMAN", 7902, "2021-05-25", 10000, NULL, 10);
Practice 5

•	Create a function named FIND_SAL_GRADE which accepts salary of an employee finds the corresponding salary grade from SALGRADE table and returns the grade. The function should 
	raise an exception if the salary value does not fit in any of the salary ranges specified in the salgrade table.
•	Create a procedure CALL_FIND_SAL_GRADE that does not accept any parameter. The procedure gives call to FIND_SAL_GRADE for each record in the emp table by passing on the salary 
	value from the current record. The procedure displays the corresponding employee number, employee name and the salary grade returned by FIND_SAL_GRADE, on the screen. The 
	procedure should handle error thrown by the function by displaying an appropriate message.
•	Give a call to CALL_FIND_SAL_GRADE through an anonymous PL/SQL block 

SOLUTION:-
	DELIMITER //
	DROP PROCEDURE IF EXISTS FIND_SAL_GRADE //
	CREATE PROCEDURE FIND_SAL_GRADE(SALARY INT)
	BEGIN
	DECLARE SAL_GRADE INT DEFAULT -1;
	SELECT GRADE INTO SAL_GRADE FROM SALGRADE WHERE SALARY BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL;
	IF SAL_GRADE = -1 THEN
		SIGNAL SQLEXCEPTION SET MESSAGE_TEXT = "SALARY DOESN'T LIE IN ANY GRADE";
	ELSE
		SELECT SAL_GRADE AS "SALARY GRADE";
	END IF;
	END //

	DROP PROCEDURE IF EXISTS CALL_FIND_SAL_GRADE //
	CREATE PROCEDURE CALL_FIND_SAL_GRADE()
	BEGIN
	DECLARE RECORDS_COUNT INT DEFAULT 0;
	DECLARE CURR_SALARY INT;
	DECLARE SAL_CURSOR CURSOR FOR SELECT SAL FROM emp WHERE SAL IS NOT NULL;
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
	BEGIN
	SELECT COUNT(*) INTO RECORDS_COUNT FROM emp;
	SELECT RECORDS_COUNT;	
	OPEN SAL_CURSOR;
	MY_LOOP : LOOP
		IF RECORDS_COUNT = 0 THEN
			LEAVE MY_LOOP;
		END IF;
		FETCH SAL_CURSOR INTO CURR_SALARY;
		
		CALL FIND_SAL_GRADE(CURR_SALARY);
		SET RECORDS_COUNT = RECORDS_COUNT - 1;
	END LOOP MY_LOOP;
	CLOSE SAL_CURSOR;
	END;
	END//
	DELIMITER ;
	
TRIGGERS

Practice 1

•	Implement the following business rule with the help of a trigger named TR_CHECK_DEPT and a procedure named SECURE_DML. Changes to data in the dept table, will be allowed only in the month of March.
•	Create a procedure called SECURE_DML that prevents the DML statement from executing in any other month than March.  In case, a user tries to modify the table in any other month, the procedure should display a message “You can modify or add a department only at the end of a financial year”
•	Create a statement level triggerTR_CHECK_DEPT on the dept table that calls the above procedure.
•	Test it by inserting a new record in the dept table.


Practice 2

•	Enforce referential integrity with a trigger named TR_CASCADE_CHANGE. When the value of DEPTNO changes in the Dept table, cascade the update to the corresponding rows in the EMP table. 
•	Test it by updating the value of a deptno from the dept table.
  
 
Practice 3

•	Create a trigger named TR_CHECK_COMM to implement the following business rule. In EMP table, employee having job as ‘Salesman’ should receive a commission. A Salesman must receive a commission of not less than Rs. 100. Employees who are not sales persons are not entitled to get commission (comm value should be NULL).
•	Test it by inserting a record in the emp table.

Practice 4

•	While modifying the EMP table, ensure that the salary is in the valid range as specified in the SALGRADE table (between lowest  losal and highest  hisal) with the help of a trigger named TR_VALIDATE_SAL.
•	Test it by updating the salary value of an existing record in the emp table.

Practice5

•	Create a table named salaryLog with the appropriate columns and insert  the empno, new grade, old salary and new salary values in salaryLog table if the grade of an employee changes. 
•	Create a trigger named TR_CHECK_GRADE that will be fired when a user modifies the EMP table. It will check whether the grade has changed by making use of the SALGRADE table. (Grade is dependent on Salary.) If grade is changed, the trigger will log the corresponding employee number, old salary, new salary and new grade into  salaryLog table. 
•	Test the working of the trigger by firing an appropriate DML query.
